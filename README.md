# maple初心者用ノート

## このドキュメントでは自身の研究で実装した内容を通して、maple初心者として躓いた内容をまとめます。

## 目次

- [pade近似の基本(関数とパッケージ)](pade近似の基本(関数とパッケージ))
- [pade近似を関数化(式を関数化する方法)](pade近似を関数化(式を関数化する方法))


## pade近似の基本(関数とパッケージ)

Mapleでは `pade(f, x, [m,n])` を使って、関数 `f` を点 `x=0` 周辺で Pade 近似できます。<br>
`pade(f,x,[m,n])`は`numapprox`というパッケージに属している関数です。<br>
このような関数を使用する場合は`numapprox:-pade(f,x,[m,n])`としなくてはなりません。<br>
また`with(numapprox)`というコマンドを打てば、`numapprox`内の関数がすべてトップレベル(直接コードを書いている場所)で使用することができるようになります。

Pade近似の基本的な使い方：
```maple
with(numapprox);
pade(exp(x),x,[2,2]);
```

パッケージの関数をバインドしない場合：
```maple
numapprox:-pade(exp(x),x,[2,2]);
```
この `:-` 記法は「numapproxパッケージの中にあるpade関数」という意味になります。


## pade近似を関数化(式を関数化する方法)

研究では指数関数のPade近似を多用しています。<br>
そのため指数の肩`x`とPade近似の次数`[m,n]`を入力すれば、それに応じた指数関数のPade近似が出力されるような関数を作りたいです。<br>
次のようにするとよいです。<br>

```maple
pade_exp := proc(xval, l1, l2)
  local x, tmpFunc;
  tmpFunc := unapply(pade(exp(x), x, [l1, l2]), x);
  return tmpFunc(xval);
end proc
```

`local`は関数内でローカル変数を生成しています。<br>
`unapply(f(x),x)`は式`f(x)`をxの関数にするコマンドです。
`tmpFunc:=x->pade(exp(x), x, [l1, l2])`でも関数化することは可能ですが、式が変数に依存している場合や評価順序が複雑な場合にはエラーが生じることがあるようです。

`unapply`によって関数化したのち、その関数に入力`xval`を代入しています。<br>
なぜこの操作が必要なのでしょうか。<br>
直接`f:=(x,l1,l2)->pade(exp(x),x,[l1,l2])`としたとします。<br>
この場合、`x=0.1`を代入したとすると関数内では`pade(exp(0.1),0.1.[l1,l2])`となっており、`pade()`に関数ではなく定数が入力されていることがわかります。<br>
そのため一旦ローカル変数`x`の式を生成したのち、それを関数化。その関数に`xval`を代入した値を返すといった手順にしなくてはならないようです。<br>

